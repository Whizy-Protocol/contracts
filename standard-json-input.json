{"language":"Solidity","sources":{"src/ProtocolSelector.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"./AccessControl.sol\";\nimport {IYieldProtocol} from \"./interfaces/IYieldProtocol.sol\";\n\n/**\n * @title ProtocolSelector\n * @dev Contract for selecting and managing yield protocols\n */\ncontract ProtocolSelector is AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint8 public constant PROTOCOL_AAVE = 1;\n    uint8 public constant PROTOCOL_MORPHO = 2;\n    uint8 public constant PROTOCOL_COMPOUND = 3;\n\n    event ProtocolRegistered(uint8 indexed protocolType, address indexed protocolAddress, string name, uint8 riskLevel);\n    event ProtocolUpdated(address indexed protocolAddress, uint256 newApy, uint256 newTvl);\n    event AutoDepositExecuted(address indexed user, address indexed protocol, uint256 amount, bool success);\n    event AutoWithdrawExecuted(address indexed user, address indexed protocol, uint256 amount, bool success);\n\n    struct ProtocolInfo {\n        uint8 protocolType;\n        address protocolAddress;\n        uint256 currentApy;\n        string name;\n        uint256 tvl;\n        uint8 riskLevel;\n        bool active;\n    }\n\n    struct SelectionResult {\n        ProtocolInfo selectedProtocol;\n        string reason;\n        ProtocolInfo[] alternativeProtocols;\n    }\n\n    ProtocolInfo[] public availableProtocols;\n    mapping(uint8 => address) public protocolTypeToAddress;\n    bool public autoSelectionEnabled;\n    uint256 public minApyThreshold;\n    uint8 public maxRiskTolerance;\n\n    mapping(address => mapping(IERC20 => uint256)) public userDeposits;\n\n    error NoProtocolsAvailable();\n    error ProtocolNotFound();\n    error InvalidProtocolType();\n    error DepositFailed();\n    error WithdrawFailed();\n    error InsufficientBalance();\n\n    /**\n     * @dev Constructor\n     * @param _minApyThreshold Minimum APY threshold in basis points\n     * @param _maxRiskTolerance Maximum risk tolerance (1-10)\n     */\n    constructor(uint256 _minApyThreshold, uint8 _maxRiskTolerance) {\n        autoSelectionEnabled = true;\n        minApyThreshold = _minApyThreshold;\n        maxRiskTolerance = _maxRiskTolerance;\n    }\n\n    /**\n     * @dev Register a new protocol\n     * @param protocolType Type of protocol (1=Aave, 2=Morpho, 3=Compound)\n     * @param protocolAddress Address of the protocol contract\n     * @param riskLevel Risk level (1=lowest, 10=highest)\n     */\n    function registerProtocol(uint8 protocolType, address protocolAddress, uint8 riskLevel) external onlyOwner {\n        require(protocolAddress != address(0), \"Invalid protocol address\");\n        require(protocolType >= 1 && protocolType <= 3, \"Invalid protocol type\");\n        require(riskLevel >= 1 && riskLevel <= 10, \"Invalid risk level\");\n\n        IYieldProtocol protocol = IYieldProtocol(protocolAddress);\n\n        ProtocolInfo memory protocolInfo = ProtocolInfo({\n            protocolType: protocolType,\n            protocolAddress: protocolAddress,\n            currentApy: protocol.getCurrentApy(),\n            name: protocol.getProtocolName(),\n            tvl: 0,\n            riskLevel: riskLevel,\n            active: true\n        });\n\n        availableProtocols.push(protocolInfo);\n        protocolTypeToAddress[protocolType] = protocolAddress;\n\n        emit ProtocolRegistered(protocolType, protocolAddress, protocolInfo.name, riskLevel);\n    }\n\n    /**\n     * @dev Select the best protocol based on APY, risk, and TVL\n     * Formula: Score = (APY × 0.5) + (TVL_normalized × 0.3) - (Risk_level × 0.2)\n     * @return bestProtocol The selected protocol info\n     */\n    function selectBestProtocol(IERC20 /* token */ ) external view returns (ProtocolInfo memory bestProtocol) {\n        if (availableProtocols.length == 0) revert NoProtocolsAvailable();\n\n        int256 bestScore = type(int256).min;\n        bool found = false;\n        uint256 maxTvl = 0;\n\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            if (availableProtocols[i].active && availableProtocols[i].tvl > maxTvl) {\n                maxTvl = availableProtocols[i].tvl;\n            }\n        }\n\n        if (maxTvl == 0) maxTvl = 1;\n\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            ProtocolInfo memory protocol = availableProtocols[i];\n\n            if (!protocol.active) continue;\n            if (protocol.currentApy < minApyThreshold) continue;\n            if (protocol.riskLevel > maxRiskTolerance) continue;\n\n            int256 apyComponent = int256(protocol.currentApy * 50);\n\n            int256 tvlNormalized = int256((protocol.tvl * 30) / maxTvl);\n\n            int256 riskComponent = int256(uint256(protocol.riskLevel) * 20);\n\n            int256 score = apyComponent + tvlNormalized - riskComponent;\n\n            if (!found || score > bestScore) {\n                bestScore = score;\n                bestProtocol = protocol;\n                found = true;\n            }\n        }\n\n        if (!found) revert NoProtocolsAvailable();\n    }\n\n    /**\n     * @dev Auto deposit tokens into the best protocol\n     * @param token The ERC20 token to deposit\n     * @param amount Amount to deposit\n     * @return success True if deposit was successful\n     * @return reason Reason for success/failure\n     */\n    function autoDeposit(IERC20 token, uint256 amount) external returns (bool success, string memory reason) {\n        require(amount > 0, \"Invalid amount\");\n\n        ProtocolInfo memory bestProtocol = this.selectBestProtocol(token);\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        token.safeIncreaseAllowance(bestProtocol.protocolAddress, amount);\n\n        try IYieldProtocol(bestProtocol.protocolAddress).deposit(token, amount) returns (bool depositSuccess) {\n            success = depositSuccess;\n            if (depositSuccess) {\n                userDeposits[msg.sender][token] += amount;\n                reason = \"Successfully deposited to highest APY protocol\";\n            } else {\n                token.safeTransfer(msg.sender, amount);\n                reason = \"Deposit failed\";\n            }\n        } catch {\n            token.safeTransfer(msg.sender, amount);\n            success = false;\n            reason = \"Protocol deposit reverted\";\n        }\n\n        emit AutoDepositExecuted(msg.sender, bestProtocol.protocolAddress, amount, success);\n    }\n\n    /**\n     * @dev Auto withdraw tokens from protocols\n     * @param token The ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     * @return amountReceived Amount actually received\n     */\n    function autoWithdraw(IERC20 token, uint256 amount) external returns (uint256 amountReceived) {\n        require(amount > 0, \"Invalid amount\");\n\n        uint256 balanceBefore = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < availableProtocols.length && amountReceived < amount; i++) {\n            ProtocolInfo memory protocol = availableProtocols[i];\n\n            if (!protocol.active) continue;\n\n            IYieldProtocol protocolContract = IYieldProtocol(protocol.protocolAddress);\n\n            uint256 protocolBalance = protocolContract.getBalance(address(protocolContract), token);\n\n            if (protocolBalance == 0) {\n                protocolBalance = protocolContract.getBalance(address(this), token);\n            }\n\n            if (protocolBalance == 0) continue;\n\n            uint256 toWithdraw = amount - amountReceived;\n            if (toWithdraw > protocolBalance) {\n                toWithdraw = protocolBalance;\n            }\n\n            uint256 totalSharesAvailable = protocolContract.getShares(address(protocolContract), token);\n\n            if (totalSharesAvailable == 0) {\n                totalSharesAvailable = protocolContract.getShares(address(this), token);\n            }\n\n            if (totalSharesAvailable == 0) continue;\n\n            uint256 sharesToWithdraw;\n\n            if (toWithdraw >= protocolBalance * 95 / 100) {\n                sharesToWithdraw = totalSharesAvailable;\n            } else if (totalSharesAvailable > toWithdraw) {\n                sharesToWithdraw = toWithdraw;\n            } else {\n                sharesToWithdraw = totalSharesAvailable;\n            }\n\n            try protocolContract.withdraw(token, sharesToWithdraw) returns (uint256 received) {\n                amountReceived += received;\n                emit AutoWithdrawExecuted(msg.sender, protocol.protocolAddress, received, true);\n            } catch {\n                emit AutoWithdrawExecuted(msg.sender, protocol.protocolAddress, 0, false);\n            }\n        }\n\n        uint256 balanceAfter = token.balanceOf(address(this));\n        uint256 actualReceived = balanceAfter - balanceBefore;\n\n        if (actualReceived == 0) revert InsufficientBalance();\n\n        uint256 toDeduct =\n            actualReceived > userDeposits[msg.sender][token] ? userDeposits[msg.sender][token] : actualReceived;\n        userDeposits[msg.sender][token] -= toDeduct;\n        token.safeTransfer(msg.sender, actualReceived);\n\n        return actualReceived;\n    }\n\n    /**\n     * @dev Get total balance across all protocols for a user\n     * @param user Address of the user\n     * @param token The ERC20 token\n     * @return totalBalance Total balance across all protocols\n     */\n    function getTotalBalance(address user, IERC20 token) external view returns (uint256 totalBalance) {\n        if (user == address(this)) {\n            for (uint256 i = 0; i < availableProtocols.length; i++) {\n                ProtocolInfo memory protocol = availableProtocols[i];\n\n                if (!protocol.active) continue;\n\n                IYieldProtocol protocolContract = IYieldProtocol(protocol.protocolAddress);\n\n                uint256 balance = protocolContract.getBalance(protocol.protocolAddress, token);\n                totalBalance += balance;\n            }\n        } else {\n            for (uint256 i = 0; i < availableProtocols.length; i++) {\n                ProtocolInfo memory protocol = availableProtocols[i];\n\n                if (!protocol.active) continue;\n\n                IYieldProtocol protocolContract = IYieldProtocol(protocol.protocolAddress);\n                uint256 balance = protocolContract.getBalance(user, token);\n                totalBalance += balance;\n            }\n        }\n    }\n\n    /**\n     * @dev Get user's tracked deposit amount (principal only, not including yield)\n     * @param user Address of the user (typically a market contract)\n     * @param token The ERC20 token\n     * @return deposit Amount user has deposited\n     */\n    function getUserDeposit(address user, IERC20 token) external view returns (uint256 deposit) {\n        deposit = userDeposits[user][token];\n    }\n\n    /**\n     * @dev Update protocol information\n     * @param protocolAddress Address of the protocol\n     */\n    function updateProtocol(address protocolAddress) external onlyOwner {\n        bool found = false;\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            if (availableProtocols[i].protocolAddress == protocolAddress) {\n                IYieldProtocol protocol = IYieldProtocol(protocolAddress);\n                availableProtocols[i].currentApy = protocol.getCurrentApy();\n                found = true;\n\n                emit ProtocolUpdated(protocolAddress, availableProtocols[i].currentApy, availableProtocols[i].tvl);\n                break;\n            }\n        }\n\n        if (!found) revert ProtocolNotFound();\n    }\n\n    /**\n     * @dev Update protocol information (alias for updateProtocol)\n     * @param protocolAddress Address of the protocol\n     */\n    function updateProtocolInfo(address protocolAddress, IERC20 /* token */ ) external onlyOwner {\n        bool found = false;\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            if (availableProtocols[i].protocolAddress == protocolAddress) {\n                IYieldProtocol protocol = IYieldProtocol(protocolAddress);\n                availableProtocols[i].currentApy = protocol.getCurrentApy();\n                found = true;\n\n                emit ProtocolUpdated(protocolAddress, availableProtocols[i].currentApy, availableProtocols[i].tvl);\n                break;\n            }\n        }\n\n        if (!found) revert ProtocolNotFound();\n    }\n\n    /**\n     * @dev Set protocol active status\n     * @param protocolAddress Address of the protocol\n     * @param active New active status\n     */\n    function setProtocolActive(address protocolAddress, bool active) external onlyOwner {\n        bool found = false;\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            if (availableProtocols[i].protocolAddress == protocolAddress) {\n                availableProtocols[i].active = active;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) revert ProtocolNotFound();\n    }\n\n    /**\n     * @dev Enable or disable auto selection\n     * @param enabled New auto selection status\n     */\n    function setAutoSelectionEnabled(bool enabled) external onlyOwner {\n        autoSelectionEnabled = enabled;\n    }\n\n    /**\n     * @dev Update minimum APY threshold\n     * @param newThreshold New minimum APY threshold\n     */\n    function setMinApyThreshold(uint256 newThreshold) external onlyOwner {\n        minApyThreshold = newThreshold;\n    }\n\n    /**\n     * @dev Update maximum risk tolerance\n     * @param newTolerance New maximum risk tolerance\n     */\n    function setMaxRiskTolerance(uint8 newTolerance) external onlyOwner {\n        require(newTolerance >= 1 && newTolerance <= 10, \"Invalid tolerance\");\n        maxRiskTolerance = newTolerance;\n    }\n\n    /**\n     * @dev Get all available protocols\n     * @return protocols Array of all protocols\n     */\n    function getAvailableProtocols() external view returns (ProtocolInfo[] memory protocols) {\n        protocols = availableProtocols;\n    }\n\n    /**\n     * @dev Get all available protocols (alias)\n     * @return protocols Array of all protocols\n     */\n    function getAllProtocols() external view returns (ProtocolInfo[] memory protocols) {\n        protocols = availableProtocols;\n    }\n\n    /**\n     * @dev Get protocol by type\n     * @param protocolType Type of protocol\n     * @return protocol Protocol information\n     */\n    function getProtocolByType(uint8 protocolType) external view returns (ProtocolInfo memory protocol) {\n        address protocolAddress = protocolTypeToAddress[protocolType];\n        if (protocolAddress == address(0)) revert ProtocolNotFound();\n\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            if (availableProtocols[i].protocolAddress == protocolAddress) {\n                return availableProtocols[i];\n            }\n        }\n\n        revert ProtocolNotFound();\n    }\n\n    /**\n     * @dev Get current best APY across all protocols\n     * @return bestApy The highest APY available\n     */\n    function getCurrentBestApy() external view returns (uint256 bestApy) {\n        for (uint256 i = 0; i < availableProtocols.length; i++) {\n            if (availableProtocols[i].active && availableProtocols[i].currentApy > bestApy) {\n                bestApy = availableProtocols[i].currentApy;\n            }\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"},"src/AccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title AccessControl\n * @dev Contract that provides basic access control with owner and pausable functionality\n */\ncontract AccessControl {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Paused(address account);\n    event Unpaused(address account);\n\n    address private _owner;\n    bool private _paused;\n\n    error NotOwner();\n    error NotAuthorized();\n    error AlreadyInitialized();\n    error IsPaused();\n\n    /**\n     * @dev Modifier to check if caller is the owner\n     */\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert NotOwner();\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if contract is not paused\n     */\n    modifier whenNotPaused() {\n        if (_paused) revert IsPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if contract is paused\n     */\n    modifier whenPaused() {\n        if (!_paused) revert NotAuthorized();\n        _;\n    }\n\n    /**\n     * @dev Constructor that initializes the owner\n     */\n    constructor() {\n        _owner = msg.sender;\n        _paused = false;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Initialize owner (alternative to constructor for proxy patterns)\n     * @param initialOwner The initial owner address\n     */\n    function initializeOwner(address initialOwner) external {\n        if (_owner != address(0)) revert AlreadyInitialized();\n        _owner = initialOwner;\n        emit OwnershipTransferred(address(0), initialOwner);\n    }\n\n    /**\n     * @dev Returns true if the contract is initialized\n     */\n    function isInitialized() external view returns (bool) {\n        return _owner != address(0);\n    }\n\n    /**\n     * @dev Returns true if the given account is the owner\n     * @param account The account to check\n     */\n    function isOwner(address account) external view returns (bool) {\n        return account == _owner;\n    }\n\n    /**\n     * @dev Returns the current owner\n     */\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account\n     * @param newOwner The address of the new owner\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"New owner cannot be zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @dev Returns true if the contract is paused\n     */\n    function paused() external view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Asserts that the caller is the owner\n     */\n    function assertOwner() external view {\n        if (msg.sender != _owner) revert NotOwner();\n    }\n\n    /**\n     * @dev Asserts that the specified account is the owner\n     * @param account The account to check as owner\n     */\n    function assertOwner(address account) external view {\n        if (account != _owner) revert NotOwner();\n    }\n\n    /**\n     * @dev Asserts that the contract is not paused\n     */\n    function assertNotPaused() external view {\n        if (_paused) revert IsPaused();\n    }\n}\n"},"src/interfaces/IYieldProtocol.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IYieldProtocol\n * @dev Interface for yield protocol adapters\n */\ninterface IYieldProtocol {\n    event Deposit(address indexed user, uint256 amount, uint256 sharesReceived);\n    event Withdrawal(address indexed user, uint256 shares, uint256 amountReceived);\n\n    /**\n     * @dev Initialize the protocol with initial parameters\n     * @param initialApy Initial APY in basis points (e.g., 500 = 5%)\n     * @param protocolFee Protocol fee in basis points\n     */\n    function initialize(uint256 initialApy, uint256 protocolFee) external;\n\n    /**\n     * @dev Deposit tokens into the yield protocol\n     * @param token The ERC20 token to deposit\n     * @param amount Amount of tokens to deposit\n     * @return success True if deposit was successful\n     */\n    function deposit(IERC20 token, uint256 amount) external returns (bool success);\n\n    /**\n     * @dev Withdraw tokens from the yield protocol\n     * @param token The ERC20 token to withdraw\n     * @param shares Amount of shares to withdraw\n     * @return amountReceived Amount of tokens received\n     */\n    function withdraw(IERC20 token, uint256 shares) external returns (uint256 amountReceived);\n\n    /**\n     * @dev Get user's balance in the protocol\n     * @param user User address\n     * @param token Token address\n     * @return balance User's balance in underlying tokens\n     */\n    function getBalance(address user, IERC20 token) external view returns (uint256 balance);\n\n    /**\n     * @dev Get user's shares in the protocol\n     * @param user User address\n     * @param token Token address\n     * @return shares User's shares\n     */\n    function getShares(address user, IERC20 token) external view returns (uint256 shares);\n\n    /**\n     * @dev Get current APY of the protocol\n     * @return apy Current APY in basis points\n     */\n    function getCurrentApy() external view returns (uint256 apy);\n\n    /**\n     * @dev Get protocol name\n     * @return name Protocol name\n     */\n    function getProtocolName() external pure returns (string memory name);\n\n    /**\n     * @dev Get total value locked in the protocol\n     * @param token Token address\n     * @return tvl Total value locked\n     */\n    function getTotalTvl(IERC20 token) external view returns (uint256 tvl);\n\n    /**\n     * @dev Get current exchange rate (shares to underlying)\n     * @param token Token address\n     * @return rate Exchange rate scaled by 1e18\n     */\n    function getExchangeRate(IERC20 token) external view returns (uint256 rate);\n\n    /**\n     * @dev Check if user is whitelisted (for protocols with whitelisting)\n     * @param user User address\n     * @return isWhitelisted True if user is whitelisted\n     */\n    function isWhitelisted(address user) external view returns (bool isWhitelisted);\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@openzeppelin/=lib/openzeppelin-contracts/","forge-std/=lib/forge-std/src/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","openzeppelin-contracts/=lib/openzeppelin-contracts/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
